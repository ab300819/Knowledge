# 9.4 完整备份工具

## 8.4.1 `XFS` 文件系统备份 `xfsdump`

* 不支援没有挂载的文件系统备份！所以只能备份已挂载的！
* 必须使用 root 的权限才能操作 (涉及文件系统的关系)
* 只能备份 XFS 文件系统啊！
* 备份下来的数据 (文件或储存媒体) 只能让 `xfsrestore` 解析
* 是透过文件系统的 UUID 来分辨各个备份档的，因此不能备份两个具有相同 UUID 的文件系统

```
[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份档] 待备份资料
[root@study ~]# xfsdump -I
选项与参数：
-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明
-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明
-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ (预设为 0，即完整备份)
-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 装置文件名或其他一般文件档名等
-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态
```

**用 `xfsdump` 备份完整的文件系统**

```
# 1. 先确定 /boot 是独立的文件系统喔！
[root@study ~]# df -h /boot
Filesystem Size Used Avail Use% Mounted on
/dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 装置！
# 看！确实是独立的文件系统喔！ /boot 是挂载点！

# 2. 將完整備份的檔名記錄成為 /srv/boot.dump ：
[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump: using file dump (drive_simple) strategy
xfsdump: version 3.1.4 (dump format 3.0) - type ^C for status and control
xfsdump: level 0 dump of study.centos.vbird:/boot              # 开始备份本机/boot 系统
xfsdump: dump date: Wed Jul  1 18:43:04 2015                   # 备份的时间
xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1      # 这次 dump 的 ID
xfsdump: session label: "boot_all"                             # 简单给予一个名字记忆
xfsdump: ino map phase 1: constructing initial dump list       # 开始备份程序
xfsdump: ino map phase 2: skipping (no pruning necessary)
xfsdump: ino map phase 3: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: estimated dump size: 103188992 bytes
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 102872168 bytes
xfsdump: dump size (non-dir files) : 102637296 bytes
xfsdump: dump complete: 1 seconds elapsed
xfsdump: Dump Summary:
xfsdump:   stream 0 /srv/boot.dump OK (success)
xfsdump: Dump Status: SUCCESS
# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！
# 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！

[root@study ~]# ll /srv/boot.dump
-rw-r--r--. 1 root root 102872168 Jul  1 18:43 /srv/boot.dump

[root@study ~]# ll /var/lib/xfsdump/inventory
-rw-r--r--. 1 root root 5080 Jul  1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj
-rw-r--r--. 1 root root  312 Jul  1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex
-rw-r--r--. 1 root root  576 Jul  1 18:43 fstab
# 使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔！
```

**用 `xfsdump` 进行累积备份**

```
# 0. 看一下有没有任何文件系统被 xfsdump 过的资料
[root@study ~]# xfsdump -I
file system 0:
    fs id:          94ac5f77-cb8a-495e-a65b-2ef7442b837c
    session 0:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:43:04 2015
        session label:  "boot_all"
        session id:     418b563f-26fa-4c9b-98b7-6f57ea0163b1
        level:          0
        resumed:        NO
        subtree:        NO
        streams:        1
        stream 0:
                pathname:       /srv/boot.dump
                start:          ino 132 offset 0
                end:            ino 2138243 offset 0
                interrupted:    NO
                media files:    1
                media file 0:
                        mfile index:    0
                        mfile type:     data
                        mfile size:     102872168
                        mfile start:    ino 132 offset 0
                        mfile end:      ino 2138243 offset 0
                        media label:    "boot_all"
                        media id:       a6168ea6-1ca8-44c1-8d88-95c863202eab
xfsdump: Dump Status: SUCCESS
# 我们可以看到目前仅有一个 session 0 的备份资料而已！而且是 level 0 

# 1. 建立一个大约 10 MB 的文件在 /boot 内：
[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10
10+0 records in
10+0 records out
10485760 bytes (10 MB) copied, 0.166128 seconds, 63.1 MB/s

# 2. 开始建立差异备份档，此时我们使用 level 1 吧：
[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot
....(中間省略)....

[root@study ~]# ll /srv/boot*
-rw-r--r--. 1 root root 102872168 Jul  1 18:43 /srv/boot.dump
-rw-r--r--. 1 root root  10510952 Jul  1 18:46 /srv/boot.dump1
# 看看文件大小，岂不是就是刚刚我们所建立的那个大文件的容量吗？

# 3. 最后再看一下是否有记录 level 1 备份的时间点
[root@study ~]# xfsdump -I
file system 0:
    fs id:          94ac5f77-cb8a-495e-a65b-2ef7442b837c
    session 0:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
....(中間省略)....

    session 1:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:46:21 2015
        session label:  "boot_2"
        session id:     c71d1d41-b3bb-48ee-bed6-d77c939c5ee8
        level:          1
        resumed:        NO
        subtree:        NO
        streams:        1
        stream 0:
                pathname:       /srv/boot.dump1
                start:          ino 455518 offset 0
....(底下省略)....
```

### 8.4.2 `XFS` 文件系统还原 `xfsrestore`

```
[root@study ~]# xfsrestore -I                                          <==用来察看备份文件资料
[root@study ~]# xfsrestore [-f 备份档] [-L S_label] [-s] 待复原目录     <==单一文件全系统复原
[root@study ~]# xfsrestore [-f 备份文件] -r 待复原目录                  <==透过累积备份文件来复原系统
[root@study ~]# xfsrestore [-f 备份文件] -i 待复原目录                  <==进入交互模式
选项与参数：
-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等
-f ：后面接的就是备份档！企业界很有可能会接 /dev/st0 等磁带机！我们这里接档名！
-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！
-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！
-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，
需要这东西来达成累积复原
-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！
```

**用 `xfsrestore` 查看 `xfsdump` 备份资料内容**

```
[root@study ~]# xfsrestore -I 

# 我们可以看到这个文件系统是 /boot 载点，然后有两个备份，一个 level 0 一个 level 1。
# 也看到这两个备份的资料他的内容大小！更重要的，就是那个 session label 喔！
```

**还原 level 0 备份**

```
# 1. 直接将数据给它覆盖回去即可！
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /boot
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.4 (dump format 3.0) - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 8 directories and 327 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 1 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)  # 是否是正确的文件啊？
xfsrestore: Restore Status: SUCCESS

# 2. 将备份资料在 /tmp/boot 底下解开！
[root@study ~]# mkdir /tmp/boot
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot
[root@study ~]# du -sm /boot /tmp/boot
109     /boot
99      /tmp/boot
# 咦！两者怎么大小不一致呢？没关系！我们来检查看看！

[root@study ~]# diff -r /boot /tmp/boot
Only in /boot: testing.img
# 看吧！原来是 /boot 我们有增加过一个文件啦！

# 3. 仅复原备份档内的 grub2 到 /tmp/boot2/ 里头去！
[root@study ~]# mkdir /tmp/boot2
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2
```

**还原累积备份**

```
# 继续复原 level 1 到 /tmp/boot 当中！
[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot
```

**仅还原部分备份的 `xfsrestore` 交互模式**

```
# 1. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！
[root@study ~]# mkdir /tmp/boot3
[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3
 ========================== subtree selection dialog ==========================

the following commands are available:
        pwd
        ls [ <path> ]
        cd [ <path> ]
        add [ <path> ]       # 可以加入复原文件列表中
        delete [ <path> ]    # 从复原列表拿掉档名！并非删除喔
        extract              # 开始复原动作！
        quit
        help

 -> ls
          455517 initramfs-3.10.0-229.el7.x86_64kdump.img
             138 initramfs-3.10.0-229.el7.x86_64.img
             141 initrd-plymouth.img
             140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a
             139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img
             137 vmlinuz-3.10.0-229.el7.x86_64
             136 symvers-3.10.0-229.el7.x86_64.gz
             135 config-3.10.0-229.el7.x86_64
             134 System.map-3.10.0-229.el7.x86_64
             133 .vmlinuz-3.10.0-229.el7.x86_64.hmac
         1048704 grub2/
             131 grub/

 -> add grub
 -> add grub2
 -> add config-3.10.0-229.el7.x86_64
 -> extract

[root@study ~]# ls -l /tmp/boot3
-rw-r--r--. 1 root root 123838 Mar  6 19:45 config-3.10.0-229.el7.x86_64
drwxr-xr-x. 2 root root     26 May  4 17:52 grub
drwxr-xr-x. 6 root root    104 Jun 25 00:02 grub2
# 就只会有 3 个档名被复原，当然，如果文件名是目录，那底下的子文件当然也会被还原回来的！
```

## 通用备份与还原工具

* `dump`
```
[root@www ~]# dump [-Suvj] [-level] [-f 备份档] 待备份数据
[root@www ~]# dump -W
选项与参数：
-S    ：仅列出后面的待备份数据需要多少磁碟空间才能够备份完毕；
-u    ：将这次 dump 的时间记录到 /etc/dumpdates 文件中；
-v    ：将 dump 的文件过程显示出来；
-j    ：加入 bzip2 的支持！将数据进行压缩，默认 bzip2 压缩等级为 2
-level：就是我们谈到的等级，从 -0 ~ -9 共十个等级；
-f    ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 装置档名等
-W    ：列出在 /etc/fstab 里面的具有 dump 配置的 partition 是否有备份过？
```

* `restore`
```
[root@www ~]# restore -t [-f dumpfile] [-h]        <==用来察看 dump 档
[root@www ~]# restore -C [-f dumpfile] [-D 挂载点] <==比较dump与实际文件
[root@www ~]# restore -i [-f dumpfile]             <==进入互动模式
[root@www ~]# restore -r [-f dumpfile]             <==还原整个文件系统
选项与参数：
相关的各种模式，各种模式无法混用喔！例如不可以写 -tC 啦！
-t  ：此模式用在察看 dump 起来的备份档中含有什么重要数据！类似 tar -t 功能；
-C  ：此模式可以将 dump 内的数据拿出来跟实际的文件系统做比较，
      最终会列出『在 dump 文件内有记录的，且目前文件系统不一样』的文件；
-i  ：进入互动模式，可以仅还原部分文件，用在 dump 目录时的还原！
-r  ：将整个 filesystem 还原的一种模式，用在还原针对文件系统的 dump 备份；
其他较常用到的选项功能：
-h  ：察看完整备份数据中的 inode 与文件系统 label 等资讯
-f  ：后面就接你要处理的那个 dump 文件罗！
-D  ：与 -C 进行搭配，可以查出后面接的挂载点与 dump 内有不同的文件！
```
