## **9.4 完整备份工具**

### **8.4.1 `XFS` 文件系统备份 `xfsdump`**

* `xfsdump` 只能备份已挂载的
* `xfsdump` 必须使用 `root` 权限
* `xfsdump` 只能备份 `XFS` 文件系统
* `xfsdump` 备份的资料，只能 `xfsrestore` 解析
* `xfsdump` 通过文件系统的 `UUID` 来判断各个备份文件，因此不能备份两个具有相同 `UUID` 的文件系统

```
[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 備份檔] 待備份資料
[root@study ~]# xfsdump -I
選項與參數：
-L  ：xfsdump 會紀錄每次備份的 session 標頭，這裡可以填寫針對此檔案系統的簡易說明
-M  ：xfsdump 可以紀錄儲存媒體的標頭，這裡可以填寫此媒體的簡易說明
-l  ：是 L 的小寫，就是指定等級～有 0~9 共 10 個等級喔！ (預設為 0，即完整備份)
-f  ：有點類似 tar 啦！後面接產生的檔案，亦可接例如 /dev/st0 裝置檔名或其他一般檔案檔名等
-I  ：從 /var/lib/xfsdump/inventory 列出目前備份的資訊狀態
```

#用 `xfsdump` 备份完整的文件系统

```
# 1. 先確定 /boot 是獨立的檔案系統喔！
[root@study ~]# df -h /boot
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda2      1014M  131M  884M  13% /boot      # 掛載 /boot 的是 /dev/vda 裝置！
# 看！確實是獨立的檔案系統喔！ /boot 是掛載點！

# 2. 將完整備份的檔名記錄成為 /srv/boot.dump ：
[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump: using file dump (drive_simple) strategy
xfsdump: version 3.1.4 (dump format 3.0) - type ^C for status and control
xfsdump: level 0 dump of study.centos.vbird:/boot              # 開始備份本機/boot系統
xfsdump: dump date: Wed Jul  1 18:43:04 2015                   # 備份的時間
xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1      # 這次dump的ID
xfsdump: session label: "boot_all"                             # 簡單給予一個名字記憶
xfsdump: ino map phase 1: constructing initial dump list       # 開始備份程序
xfsdump: ino map phase 2: skipping (no pruning necessary)
xfsdump: ino map phase 3: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: estimated dump size: 103188992 bytes
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 102872168 bytes
xfsdump: dump size (non-dir files) : 102637296 bytes
xfsdump: dump complete: 1 seconds elapsed
xfsdump: Dump Summary:
xfsdump:   stream 0 /srv/boot.dump OK (success)
xfsdump: Dump Status: SUCCESS
# 在指令的下達方面，你也可以不加 -L 及 -M 的，只是那就會進入互動模式，要求你 enter！
# 而執行 xfsdump 的過程中會出現如上的一些訊息，您可以自行仔細的觀察！

[root@study ~]# ll /srv/boot.dump
-rw-r--r--. 1 root root 102872168 Jul  1 18:43 /srv/boot.dump

[root@study ~]# ll /var/lib/xfsdump/inventory
-rw-r--r--. 1 root root 5080 Jul  1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj
-rw-r--r--. 1 root root  312 Jul  1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex
-rw-r--r--. 1 root root  576 Jul  1 18:43 fstab
# 使用了 xfsdump 之後才會有上述 /var/lib/xfsdump/inventory 內的檔案產生喔！
```

#用 `xfsdump` 进行累积备份

```
# 0. 看一下有沒有任何檔案系統被 xfsdump 過的資料？
[root@study ~]# xfsdump -I
file system 0:
    fs id:          94ac5f77-cb8a-495e-a65b-2ef7442b837c
    session 0:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:43:04 2015
        session label:  "boot_all"
        session id:     418b563f-26fa-4c9b-98b7-6f57ea0163b1
        level:          0
        resumed:        NO
        subtree:        NO
        streams:        1
        stream 0:
                pathname:       /srv/boot.dump
                start:          ino 132 offset 0
                end:            ino 2138243 offset 0
                interrupted:    NO
                media files:    1
                media file 0:
                        mfile index:    0
                        mfile type:     data
                        mfile size:     102872168
                        mfile start:    ino 132 offset 0
                        mfile end:      ino 2138243 offset 0
                        media label:    "boot_all"
                        media id:       a6168ea6-1ca8-44c1-8d88-95c863202eab
xfsdump: Dump Status: SUCCESS
# 我們可以看到目前僅有一個 session 0 的備份資料而已！而且是 level 0 喔！

# 1. 先惡搞一下，建立一個大約 10 MB 的檔案在 /boot 內：
[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10
10+0 records in
10+0 records out
10485760 bytes (10 MB) copied, 0.166128 seconds, 63.1 MB/s

# 2. 開始建立差異備份檔，此時我們使用 level 1 吧：
[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot
....(中間省略)....

[root@study ~]# ll /srv/boot*
-rw-r--r--. 1 root root 102872168 Jul  1 18:43 /srv/boot.dump
-rw-r--r--. 1 root root  10510952 Jul  1 18:46 /srv/boot.dump1
# 看看檔案大小，豈不是就是剛剛我們所建立的那個大檔案的容量嗎？ ^_^

# 3. 最後再看一下是否有記錄 level 1 備份的時間點呢？
[root@study ~]# xfsdump -I
file system 0:
    fs id:          94ac5f77-cb8a-495e-a65b-2ef7442b837c
    session 0:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
....(中間省略)....

    session 1:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:46:21 2015
        session label:  "boot_2"
        session id:     c71d1d41-b3bb-48ee-bed6-d77c939c5ee8
        level:          1
        resumed:        NO
        subtree:        NO
        streams:        1
        stream 0:
                pathname:       /srv/boot.dump1
                start:          ino 455518 offset 0
....(底下省略)....
```

### **8.4.2 `XFS` 文件系统还原 `xfsrestore`**

```
[root@study ~]# xfsrestore -I                                       <==用來察看備份檔案資料
[root@study ~]# xfsrestore [-f 備份檔] [-L S_label] [-s] 待復原目錄 <==單一檔案全系統復原
[root@study ~]# xfsrestore [-f 備份檔] -r 待復原目錄                <==透過累積備份檔來復原系統
[root@study ~]# xfsrestore [-f 備份檔] -i 待復原目錄                <==進入互動模式
選項與參數：
-I  ：跟 xfsdump 相同的輸出！可查詢備份資料，包括 Label 名稱與備份時間等
-f  ：後面接的就是備份檔！企業界很有可能會接 /dev/st0 等磁帶機！我們這裡接檔名！
-L  ：就是 Session 的 Label name 喔！可用 -I 查詢到的資料，在這個選項後輸入！
-s  ：需要接某特定目錄，亦即僅復原某一個檔案或目錄之意！
-r  ：如果是用檔案來儲存備份資料，那這個就不需要使用。如果是一個磁帶內有多個檔案，
      需要這東西來達成累積復原
-i  ：進入互動模式，進階管理員使用的！一般我們不太需要操作它！
```

#用 `xfsrestore` 查看 `xfsdump` 备份资料内容

```
[root@study ~]# xfsrestore -I 
file system 0:
    fs id:          94ac5f77-cb8a-495e-a65b-2ef7442b837c
    session 0:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:43:04 2015
        session label:  "boot_all"
        session id:     418b563f-26fa-4c9b-98b7-6f57ea0163b1
        level:          0
                pathname:       /srv/boot.dump
                        mfile size:     102872168
                        media label:    "boot_all"
    session 1:
        mount point:    study.centos.vbird:/boot
        device:         study.centos.vbird:/dev/vda2
        time:           Wed Jul  1 18:46:21 2015
        session label:  "boot_2"
        session id:     c71d1d41-b3bb-48ee-bed6-d77c939c5ee8
        level:          1
                pathname:       /srv/boot.dump1
                        mfile size:     10510952
                        media label:    "boot_2"
xfsrestore: Restore Status: SUCCESS
# 鳥哥已經將不重要的項目刪除了，所以上面的輸出是經過經簡化的結果！
# 我們可以看到這個檔案系統是 /boot 載點，然後有兩個備份，一個 level 0 一個 level 1。
# 也看到這兩個備份的資料他的內容大小！更重要的，就是那個 session label 喔！
```

#还原 level 0 备份

```
# 1. 直接將資料給它覆蓋回去即可！
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /boot
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.4 (dump format 3.0) - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 8 directories and 327 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 1 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)  # 是否是正確的檔案啊？
xfsrestore: Restore Status: SUCCESS

# 2. 將備份資料在 /tmp/boot 底下解開！
[root@study ~]# mkdir /tmp/boot
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot
[root@study ~]# du -sm /boot /tmp/boot
109     /boot
99      /tmp/boot
# 咦！兩者怎麼大小不一致呢？沒關係！我們來檢查看看！

[root@study ~]# diff -r /boot /tmp/boot
Only in /boot: testing.img
# 看吧！原來是 /boot 我們有增加過一個檔案啦！

# 3. 僅復原備份檔內的 grub2 到 /tmp/boot2/ 裡頭去！
[root@study ~]# mkdir /tmp/boot2
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2
```

#还原累积备份

```
# 繼續復原 level 1 到 /tmp/boot 當中！
[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot
```

#仅还原部分备份的 `xfsrestore` 互动模式

```
# 1. 先進入備份檔案內，準備找出需要備份的檔名資料，同時預計還原到 /tmp/boot3 當中！
[root@study ~]# mkdir /tmp/boot3
[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3
 ========================== subtree selection dialog ==========================

the following commands are available:
        pwd
        ls [ <path> ]
        cd [ <path> ]
        add [ <path> ]       # 可以加入復原檔案列表中
        delete [ <path> ]    # 從復原列表拿掉檔名！並非刪除喔！
        extract              # 開始復原動作！
        quit
        help

 -> ls
          455517 initramfs-3.10.0-229.el7.x86_64kdump.img
             138 initramfs-3.10.0-229.el7.x86_64.img
             141 initrd-plymouth.img
             140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a
             139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img
             137 vmlinuz-3.10.0-229.el7.x86_64
             136 symvers-3.10.0-229.el7.x86_64.gz
             135 config-3.10.0-229.el7.x86_64
             134 System.map-3.10.0-229.el7.x86_64
             133 .vmlinuz-3.10.0-229.el7.x86_64.hmac
         1048704 grub2/
             131 grub/

 -> add grub
 -> add grub2
 -> add config-3.10.0-229.el7.x86_64
 -> extract

[root@study ~]# ls -l /tmp/boot3
-rw-r--r--. 1 root root 123838 Mar  6 19:45 config-3.10.0-229.el7.x86_64
drwxr-xr-x. 2 root root     26 May  4 17:52 grub
drwxr-xr-x. 6 root root    104 Jun 25 00:02 grub2
# 就只會有 3 個檔名被復原，當然，如果檔名是目錄，那底下的子檔案當然也會被還原回來的！
```

### 通用备份与还原工具

* `dump`
```
[root@www ~]# dump [-Suvj] [-level] [-f 备份档] 待备份数据
[root@www ~]# dump -W
选项与参数：
-S    ：仅列出后面的待备份数据需要多少磁碟空间才能够备份完毕；
-u    ：将这次 dump 的时间记录到 /etc/dumpdates 文件中；
-v    ：将 dump 的文件过程显示出来；
-j    ：加入 bzip2 的支持！将数据进行压缩，默认 bzip2 压缩等级为 2
-level：就是我们谈到的等级，从 -0 ~ -9 共十个等级；
-f    ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 装置档名等
-W    ：列出在 /etc/fstab 里面的具有 dump 配置的 partition 是否有备份过？
```

* `restore`
```
[root@www ~]# restore -t [-f dumpfile] [-h]        <==用来察看 dump 档
[root@www ~]# restore -C [-f dumpfile] [-D 挂载点] <==比较dump与实际文件
[root@www ~]# restore -i [-f dumpfile]             <==进入互动模式
[root@www ~]# restore -r [-f dumpfile]             <==还原整个文件系统
选项与参数：
相关的各种模式，各种模式无法混用喔！例如不可以写 -tC 啦！
-t  ：此模式用在察看 dump 起来的备份档中含有什么重要数据！类似 tar -t 功能；
-C  ：此模式可以将 dump 内的数据拿出来跟实际的文件系统做比较，
      最终会列出『在 dump 文件内有记录的，且目前文件系统不一样』的文件；
-i  ：进入互动模式，可以仅还原部分文件，用在 dump 目录时的还原！
-r  ：将整个 filesystem 还原的一种模式，用在还原针对文件系统的 dump 备份；
其他较常用到的选项功能：
-h  ：察看完整备份数据中的 inode 与文件系统 label 等资讯
-f  ：后面就接你要处理的那个 dump 文件罗！
-D  ：与 -C 进行搭配，可以查出后面接的挂载点与 dump 内有不同的文件！
```
