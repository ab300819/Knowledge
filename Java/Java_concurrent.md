#  Java 多线程

**JUC**

**AQS**

**CAS**

## Java 中锁分类

### #公平锁/非公平锁

* 公平锁是指多个线程按照申请锁的顺序来获取锁；
* 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于 `ReentrantLock` 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>
对于 `Synchronized` 而言，也是一种非公平锁。由于其并不像 `ReentrantLock` 是通过 *AQS* 的来实现线程调度，所以并没有任何办法使其变成公平锁。

### #独享锁/共享锁

* 独享锁是指该锁一次只能被一个线程所持有；
* 共享锁是指该锁可被多个线程所持有。

对于 `ReentrantLock` 而言，其是独享锁。但是对于 `Lock` 的另一个实现类 `ReadWriteLock` ，其读锁是共享锁，其写锁是独享锁。<br>
读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。<br>
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
对于Synchronized而言，当然是独享锁。<br>

### #互斥锁/读写锁

独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>

* 互斥锁在 Java 中的具体实现就是 `ReentrantLock`
* 读写锁在 Java 中的具体实现就是 `ReadWriteLock`

### #乐观锁/悲观锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<br>
悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<br>
乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。<br>
悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。<br>
悲观锁在 Java 中的使用，就是利用各种锁。<br>
乐观锁在 Java 中的使用，是无锁编程，常常采用的是 *CAS* 算法，典型的例子就是原子类，通过 *CAS* 自旋实现原子操作的更新。

### #偏向锁/轻量级锁/重量级锁

这三种锁是指锁的状态，并且是针对 `Synchronized`。在Java 5通过引入锁升级的机制来实现高效 `Synchronized`，这三种锁的状态是通过对象监视器在对象头中的字段来表明的。<br>
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。<br>
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。<br>

### #可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。`ReentrantLock` 是一个可重入锁，`Synchronized` 也是一个可重入锁，可重入锁的一个好处是可一定程度避免死锁。

```java
synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000);
}
```

### #分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于 `ConcurrentHashMap` 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。<br>
`ConcurrentHashMap` 中的分段锁称为 `Segment` ，它即类似于 `HashMap`（JDK7与JDK8中 `HashMap` 的实现）的结构，即内部拥有一个 `Entry` 数组，数组中的每个元素又是一个链表；同时又是一个 `ReentrantLock`（ `Segment` 继承了 `ReentrantLock`)。<br>
当需要 `put` 元素的时候，并不是对整个 `HashMap` 进行加锁，而是先通过 `hashcode` 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 `put` 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>
但是，在统计 `size` 的时候，可就是获取 `HashMap` 全局信息的时候，就需要获取所有的分段锁才能统计。<br>
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。<br>

### #自旋锁

自旋锁并不是一种锁，而是一种锁优化技术。<br>

```java
public class SpinLock {

    private AtomicReference<Thread> sign =new AtomicReference<>();

    public void lock(){
        Thread current = Thread.currentThread();
        while(!sign .compareAndSet(null, current)){
        }
    }

    public void unlock (){
        Thread current = Thread.currentThread();
        sign .compareAndSet(current, null);
    }
}
```

使用了 *CAS* 原子操作，`lock` 函数将 `current` 设置为当前线程，并且预测原来的值为空。`unlock` 函数将 `current` 设置为 `null`，并且预测值为当前线程。<br>
当有第二个线程调用 `lock` 操作时由于 `current` 值不为空，导致循环一直被执行，直至第一个线程调用 `unlock` 函数将 `current` 设置为 `null`，第二个线程才能进入临界区。<br>
由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。

### #阻塞锁
### #对象锁
### #线程锁
### #锁粗化
### #锁消除
### #锁膨胀
### #信号量